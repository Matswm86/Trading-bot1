class AdvancedTradingStrategy(bt.Strategy):
    params = (
        ('rr_ratio', 3.0),  # Risk-Reward ratio set to 3.0
        ('rsi_period', 14),  # RSI period
        ('volume_threshold', 1.5),  # Volume threshold for zones
        ('fvg_threshold', 0.5),  # Fair Value Gap threshold
        ('engulfing_lookback', 2),  # Lookback period for engulfing patterns
    )

    def __init__(self):
        # Define indicators
        self.rsi = bt.indicators.RSI(self.data.close, period=self.params.rsi_period)
        self.stochastic = bt.indicators.Stochastic(self.data)

        # Calculate average volume dynamically using SMA
        self.avg_volume = bt.indicators.SimpleMovingAverage(self.data.volume, period=20)

    def is_demand_zone(self, index: int) -> bool:
        """
        Identify demand zones based on swing lows and volume.
        """
        # Check for swing low
        if (self.data.low[index] < self.data.low[index - 1] and
            self.data.low[index] < self.data.low[index + 1]):
            # Check for high volume
            if self.data.volume[index] > self.avg_volume[index] * self.params.volume_threshold:
                return True
        return False

    def is_supply_zone(self, index: int) -> bool:
        """
        Identify supply zones based on swing highs and volume.
        """
        # Check for swing high
        if (self.data.high[index] > self.data.high[index - 1] and
            self.data.high[index] > self.data.high[index + 1]):
            # Check for high volume
            if self.data.volume[index] > self.avg_volume[index] * self.params.volume_threshold:
                return True
        return False

    def is_fair_value_gap(self, index: int) -> bool:
        """
        Identify Fair Value Gaps (FVGs).
        """
        # Calculate the gap between the current candle and the previous candle
        gap = abs(self.data.close[index] - self.data.open[index - 1])
        return gap > self.params.fvg_threshold

    def is_engulfing_pattern(self, index: int) -> bool:
        """
        Identify engulfing patterns.
        """
        # Bullish engulfing
        if (self.data.close[index] > self.data.open[index - 1] and
            self.data.open[index] < self.data.close[index - 1]):
            return True
        # Bearish engulfing
        elif (self.data.close[index] < self.data.open[index - 1] and
              self.data.open[index] > self.data.close[index - 1]):
            return True
        return False

    def next(self):
        # Check for entry conditions
        for i in range(self.params.engulfing_lookback, len(self.data) - 1):
            if self.is_demand_zone(i) and self.is_bullish_momentum():
                self.enter_trade('long', i)
            elif self.is_supply_zone(i) and self.is_bearish_momentum():
                self.enter_trade('short', i)

    def enter_trade(self, direction: str, index: int):
        """
        Enter a trade with stop-loss and take-profit based on RR ratio.
        """
        entry_price = self.data.close[index]
        if direction == 'long':
            stop_loss = self.calculate_stop_loss(entry_price, 'long')
            take_profit = entry_price + (entry_price - stop_loss) * self.params.rr_ratio
            self.buy()
            self.sell(exectype=bt.Order.Stop, price=stop_loss)
            self.sell(exectype=bt.Order.Limit, price=take_profit)
        elif direction == 'short':
            stop_loss = self.calculate_stop_loss(entry_price, 'short')
            take_profit = entry_price - (stop_loss - entry_price) * self.params.rr_ratio
            self.sell()
            self.buy(exectype=bt.Order.Stop, price=stop_loss)
            self.buy(exectype=bt.Order.Limit, price=take_profit)

    def calculate_stop_loss(self, entry_price: float, direction: str) -> float:
        """
        Calculate stop-loss level based on supply/demand zones.
        """
        if direction == 'long':
            # Find nearest demand zone below entry
            for i in range(len(self.data)):
                if self.is_demand_zone(i) and self.data.low[i] < entry_price:
                    return self.data.low[i] * 0.995  # Additional buffer
        elif direction == 'short':
            # Find nearest supply zone above entry
            for i in range(len(self.data)):
                if self.is_supply_zone(i) and self.data.high[i] > entry_price:
                    return self.data.high[i] * 1.005  # Additional buffer
        # Default to 2% stop loss if no suitable zones found
        return entry_price * 0.98 if direction == 'long' else entry_price * 1.02

    def is_bullish_momentum(self):
        # Check RSI/Stochastic for bullish momentum
        return self.rsi < 30 and self.stochastic.percK < 20

    def is_bearish_momentum(self):
        # Check RSI/Stochastic for bearish momentum
        return self.rsi > 70 and self.stochastic.percK > 80
